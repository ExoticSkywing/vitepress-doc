你遇到的问题很可能与 `reserve()` 和 `resize()` 的行为差异有关，结合底层数组指针的操作，以下是详细分析和解决方案：

---

### **原因分析**
1. **`reserve()` 的作用**  
   - `vec.reserve(n)` **仅预分配内存**，将 `capacity()`（容量）扩大到至少 `n`，但 **不会改变 `size()`（元素数量）**。
   - 此时 `vec.size()` 仍为 0，所有通过 `push_back()` 添加的元素会从索引 0 开始填充，并逐步增加 `size()`。

2. **直接操作底层指针的陷阱**  
   - `vec.data()` 返回指向底层数组的指针，但如果你直接通过指针写入数据（例如 `data()[i] = value`），这 **不会更新 `size()`**。
   - 即使内存已分配，`vec` 仍认为没有元素（`size()` 为 0），因此 `vec[i]` 或迭代器访问时可能无法正确获取值（属于未定义行为）。

3. **`resize()` 的修复效果**  
   - `vec.resize(n)` 会强制将 `size()` 设为 `n`，并根据需要初始化新元素。
   - 此时通过 `data()` 指针操作或 `vec[i]` 访问元素时，`size()` 已正确更新，访问合法。

---

### **示例复现问题**
假设你写了类似以下代码：
```cpp
std::vector<int> vec;
vec.reserve(10);       // 预分配容量为 10，size() 仍为 0

// 直接通过指针写入数据（但未更新 size()）
int* ptr = vec.data();
ptr[0] = 42;          // 写入第一个位置，但 vec.size() 仍为 0

vec.push_back(1);      // size() 变为 1，此时 ptr[0] 可能被覆盖（取决于实现）

std::cout << vec.size();      // 输出 1（但你以为已经写入了 42 和 1？）
std::cout << vec[0];          // 输出 1（42 被 push_back(1) 覆盖）
```

---

### **解决方案**
1. **明确 `reserve()` 的用途**  
   - `reserve()` 仅用于优化性能（减少多次 `push_back()` 时的内存重分配），不会创建有效元素。
   - 若需要初始化元素，应使用 `resize()` 或 `vector<int> vec(n, 0)`。

2. **避免直接操作底层指针**  
   - 除非你明确知道自己在做什么，否则优先使用 `push_back()`、`emplace_back()` 或迭代器插入元素。
   - 如果必须直接操作指针：
     ```cpp
     vec.resize(n);        // 先设置 size()
     int* ptr = vec.data();
     ptr[i] = value;       // 安全操作，因为 size() 已正确更新
     ```

3. **区分 `reserve()` 和 `resize()`**
   | 方法         | 作用                           | 是否改变 `size()` | 是否初始化元素       |
   |--------------|--------------------------------|-------------------|----------------------|
   | `reserve(n)` | 预分配内存（容量 ≥n）          | 否                | 否                   |
   | `resize(n)`  | 调整元素数量为 `n`             | 是                | 是（默认或指定值初始化） |
   | `push_back()`| 尾部添加元素                   | 是（`size()++`）  | 是                   |

---

### **修正后的代码示例**
```cpp
std::vector<int> vec;
vec.reserve(10);       // 预分配容量，size() 仍为 0

vec.push_back(1);      // size() 变为 1
vec.push_back(2);      // size() 变为 2

// 正确访问方式
std::cout << vec.size();   // 输出 2
std::cout << vec[0];       // 输出 1

// 若需要直接操作指针且确保安全：
vec.resize(10);           // size() 变为 10，新增元素初始化为 0
int* ptr = vec.data();
ptr[5] = 100;             // 合法操作，size() 足够大
```

---

### **总结**
- **`reserve()` + `push_back()`**：适用于预先分配内存后逐步添加元素，此时 `size()` 会自动增长。
- **`resize()` + 指针操作**：适用于需要直接操作底层数组且已知最终元素数量的场景。
- **永远不要混合这两种模式**：在 `reserve()` 后直接通过指针写入数据而未调用 `push_back()` 或 `resize()`，会导致 `size()` 与实际数据不一致，引发未定义行为。

你的问题正是因为 `reserve()` 后直接操作指针但未更新 `size()`，导致逻辑上元素“不存在”。改用 `resize()` 后强制修正了 `size()`，因此访问恢复正常。